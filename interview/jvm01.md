# JVM 面试题汇总（01）

> 本文针对常见 JVM 面试题做系统总结，并配合大量 ASCII 示意图帮助记忆。

---

## 1. 说一下 JVM 的主要组成部分？及其作用？

**整体结构示意：**

```text
+---------------------------------------------------+
|                       JVM                         |
|                                                   |
|  +---------------- Runtime Data Area -----------+ |
|  |  方法区/元空间  |  堆  | 栈 | 本地方法栈 | PC | |
|  +------------------------------------------------ |
|                                                   |
|  +----------- Execution Engine -----------------+ |
|  |  解释器  |  即时编译器 JIT  |  GC 子系统      | |
|  +-----------------------------------------------+ |
|                                                   |
|  +----------- Class Loader System --------------+ |
|  |  启动类加载器 | 扩展类加载器 | 应用类加载器   | |
|  +-----------------------------------------------+ |
|                                                   |
|  +----------- Native Interface -----------------+ |
|  |                 JNI                          | |
|  +-----------------------------------------------+ |
+---------------------------------------------------+
```

**核心组件：**
- **类加载子系统（Class Loader Subsystem）**
  - 负责加载 `.class` 字节码到 JVM 中
  - 实现双亲委派，保证类唯一性和安全性
- **运行时数据区（Runtime Data Area）**
  - 存放类信息、对象、栈帧、本地变量等
- **执行引擎（Execution Engine）**
  - 解释器：逐行解释执行字节码
  - JIT 编译器：热点代码编译为本地机器码
  - GC：垃圾回收子系统
- **本地接口（JNI）与本地库**
  - 调用 C/C++ 等本地代码
- **其他：**
  - 即时编译器优化（C1、C2）
  - 监控和调试接口（JVMTI）

---

## 2. 说一下 JVM 运行时数据区域？

**JVM 内存结构示意：**

```text
+--------------------+  线程共享
|   方法区 / 元空间  |  <- 类信息、常量、静态变量
+--------------------+
|        堆          |  <- 对象实例、数组
+--------------------+
|   虚拟机栈 (T1)    |  <- 每个线程一个栈
+--------------------+
|   虚拟机栈 (T2)    |
+--------------------+
|  本地方法栈 (T1)   |
+--------------------+
|  本地方法栈 (T2)   |
+--------------------+
|   程序计数器 (T1)  |
+--------------------+
|   程序计数器 (T2)  |
+--------------------+
```

**详细说明：**
- **程序计数器（PC Register，线程私有）**
  - 保存下一条要执行的字节码指令地址
- **虚拟机栈（Java Stack，线程私有）**
  - 由一个个栈帧组成
  - 每个栈帧对应一次方法调用
  - 栈帧结构：局部变量表、操作数栈、动态链接、返回地址
- **本地方法栈（Native Method Stack）**
  - 为本地方法服务，类似虚拟机栈
- **堆（Heap，线程共享）**
  - 存放对象实例、数组
  - 分为新生代（Eden+S0+S1）、老年代
- **方法区 / 元空间（Method Area / Metaspace，线程共享）**
  - 存放类的结构信息、运行时常量池、静态变量
  - JDK8 之前：永久代 PermGen
  - JDK8 之后：元空间 Metaspace（使用本地内存）

---

## 3. 说一下堆栈的区别？

**对比示意：**

```text
线程1：                         线程共享：
+-----------------+             +------------------+
|  Java 栈        |             |       堆         |
|  +-----------+  |   引用 ---> |  +------------+  |
|  | 栈帧:main |--+-------------|->|  对象 o1   |  |
|  +-----------+  |             |  +------------+  |
+-----------------+             +------------------+
```

**栈（Stack）：**
- 线程私有，生命周期随线程
- 存放：局部变量、引用、方法调用信息
- 特点：
  - 空间小、访问快
  - 先进后出（FILO）
  - 不参与 GC，方法结束栈帧弹出

**堆（Heap）：**
- 线程共享
- 存放：对象实例、数组
- 由 GC 管理生命周期
- 分代管理：新生代 + 老年代

**区别小结：**
- 管理者不同：栈由 JVM 自动管理，堆由 GC 管理
- 线程可见性不同：栈私有，堆共享
- 存储内容不同：栈存局部变量和引用，堆存对象本身

---

## 4. 队列和栈是什么？有什么区别？

**栈（Stack）示意：**

```text
 push ->
+-----+
|  3  |  <- top
+-----+
|  2  |
+-----+
|  1  |
+-----+
  bottom

出栈：pop()  => 3,2,1
顺序：LIFO
```

**队列（Queue）示意：**

```text
入队 enqueue ->           出队 dequeue ->
   front                         rear
    |                             |
    v                             v
+-----+-----+-----+-----+-----+-----+
|  1  |  2  |  3  |     |     |     |
+-----+-----+-----+-----+-----+-----+

顺序：FIFO
```

**区别：**
- 栈：后进先出（LIFO），典型应用：函数调用栈、撤销操作
- 队列：先进先出（FIFO），典型应用：任务排队、消息队列

---

## 5. 什么是双亲委派模型？

**类加载器层次结构：**

```text
          +----------------------+
          |  BootstrapClassLoader|
          +----------+-----------+
                     |
          +----------v-----------+
          |  ExtensionClassLoader|
          +----------+-----------+
                     |
          +----------v-----------+
          |  AppClassLoader      |
          +----------+-----------+
                     |
          +----------v-----------+
          |  自定义 ClassLoader  |
          +----------------------+
```

**加载流程示意：**

```text
loadClass("java.lang.String") 调用顺序

自定义 CL -> 父 CL -> ... -> Bootstrap CL
  |                         |
  +----> 若父加载成功则直接返回
  +----> 若父加载失败再由当前 CL 尝试
```

**作用：**
- 避免同一个类被重复加载，保证 Java 核心类库的安全性
- 防止用户自定义与 JDK 核心类同名类被错误加载

---

## 6. 说一下类加载的执行过程？

**类加载生命周期：**

```text
+----------+    +---------+    +-----------+
|  加载    | -> |  连接   | -> |  初始化   |
+----------+    |         |    +-----------+
                |  +----+ |
                |  |验证| |
                |  +----+ |
                |  |准备| |
                |  +----+ |
                |  |解析| |
                |  +----+ |
```

1. **加载（Loading）**
   - 通过类加载器找到 class 字节码
   - 读入内存，生成 `Class` 对象
2. **验证（Verification）**
   - 验证字节码格式、安全性
3. **准备（Preparation）**
   - 为静态变量分配内存并设置默认值
   - 如 `static int a = 1;` 此时 a=0
4. **解析（Resolution）**
   - 将常量池中的符号引用替换为直接引用
5. **初始化（Initialization）**
   - 执行类变量的赋值和静态代码块
   - 按照代码顺序执行

---

## 7. 怎么判断对象是否可以被回收？

**早期：引用计数法（已基本不用）**
- 每个对象一个引用计数器
- 引用 +1，引用失效 -1
- 计数为 0 可回收
- 缺点：无法解决循环引用

**现在：可达性分析（Reachability Analysis）**

```text
GC Roots
  |
  v
+------+      +------+
|Root1|----->| objA |-----> objB
+------+      +------+
               ^
               |
             objC

不可达对象：从 GC Roots 出发，无法到达的对象
```

- 从 GC Roots 出发沿引用链向下搜索
- 可达的对象=存活对象
- 不可达的对象=可回收

**GC Roots 典型包括：**
- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中静态变量、常量引用的对象
- 活跃线程对象

---

## 8. Java 中都有哪些引用类型？

```text
引用强度：强引用 > 软引用 > 弱引用 > 虚引用
```

1. **强引用（StrongReference）**
   - 普通引用，如 `Object o = new Object();`
   - 只要有强引用，GC 永不回收
2. **软引用（SoftReference）**
   - 内存不足时才回收
   - 适合做缓存
3. **弱引用（WeakReference）**
   - 只要发生 GC 就会回收
   - 适合做缓存索引、ThreadLocal Map key
4. **虚引用（PhantomReference）**
   - 不影响对象生命周期
   - 只能配合 `ReferenceQueue` 使用
   - 用于在对象被回收时收到通知（管理堆外内存等）

---

## 9. 说一下 JVM 有哪些垃圾回收算法？

**示意：**

```text
复制算法：
From 区         To 区
+------+       +------+ 
|存活对象| --> |存活对象|
+------+       +------+ 

标记-清除：
+--------------------+
|存活|垃圾|存活|垃圾|  标记 -> 清除垃圾，产生碎片
+--------------------+

标记-整理：
+--------------------+
|存活|垃圾|存活|垃圾|
+--------------------+
   标记   整理
+--------------------+
|存活|存活|空空空空|
+--------------------+
```

- **标记-清除（Mark-Sweep）**
  - 阶段：标记存活对象 → 清除未标记对象
  - 缺点：碎片多
- **复制（Copying）**
  - 将存活对象复制到另一块区域
  - 优点：无碎片，适合新生代
  - 缺点：需要两倍内存
- **标记-整理（Mark-Compact）**
  - 标记后，将存活对象向一端移动
  - 适合老年代
- **分代收集（Generational Collection）**
  - 新生代：复制算法
  - 老年代：标记-清除/标记-整理

---

## 10. 说一下 JVM 有哪些垃圾回收器？

**JDK8 常见 GC 组合示意：**

```text
新生代                老年代
+-----------------+  +-----------------+
|  Serial         |  |  Serial Old     |
|  ParNew         |  |  CMS            |
|  Parallel Scav. |  |  Parallel Old   |
+-----------------+  +-----------------+

JDK9+:
+-----------------+
|  G1 (分区式)    |
+-----------------+
```

- **Serial / Serial Old**：单线程 GC，适合 Client 模式
- **ParNew**：新生代多线程 GC，常与 CMS 搭配
- **Parallel Scavenge / Parallel Old**：吞吐量优先
- **CMS（Concurrent Mark Sweep）**：低停顿垃圾回收器
- **G1（Garbage First）**：面向服务端的低延迟收集器

---

## 11. 详细介绍一下 CMS 垃圾回收器？

**CMS 工作过程示意：**

```text
        STW              并发               STW         并发
  +------------+  +--------------+   +-------------+ +---------+
  | 初始标记   |->| 并发标记     |-->| 重新标记    |->| 并发清除 |
  +------------+  +--------------+   +-------------+ +---------+
```

- **目标**：最短停顿时间，适合对响应时间敏感的应用
- **阶段：**
  1. 初始标记（STW）
     - 仅标记与 GC Roots 直接关联的对象
     - 停顿时间短
  2. 并发标记
     - 与用户线程并发运行
     - 追踪对象引用关系
  3. 重新标记（STW）
     - 修正并发标记阶段因用户线程运行导致的变化
  4. 并发清除
     - 清除不可达对象
- **优点：**
  - 停顿时间短
  - 大部分工作在并发阶段完成
- **缺点：**
  - 对 CPU 资源敏感
  - 会产生内存碎片
  - 容易出现并发模式失败（Concurrent Mode Failure）

---

## 12. 新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？

```text
新生代 GC：
- Serial
- ParNew
- Parallel Scavenge

老年代 GC：
- Serial Old
- Parallel Old
- CMS
- G1 覆盖整个堆
```

**区别：**
- 新生代：
  - 对象存活率低
  - 回收频繁
  - 多用复制算法
- 老年代：
  - 对象存活率高
  - 回收频率低
  - 多用标记-清除 / 标记-整理

---

## 13. 简述分代垃圾回收器是怎么工作的？

**堆分代示意：**

```text
+---------------------------------------------------+
|                      堆 Heap                      |
+------------------+--------------------------------+
|     新生代       |            老年代             |
| +-----+---------+|                                |
| |Eden | S0 | S1 ||                                |
| +-----+---------+|                                |
+------------------+--------------------------------+
```

**基本思想：**
- 绝大多数对象“朝生夕死”
- 不同生命周期的对象放在不同区域
- 对不同区域使用不同回收策略

**工作流程：**
1. 对象优先分配在 Eden 区
2. Eden 满触发 Minor GC：
   - 存活对象复制到 S0/S1
   - 年龄增加，达到阈值晋升老年代
3. 老年代满触发 Major GC / Full GC
4. Full GC 同时回收新生代和老年代

---

## 14. 说一下 JVM 调优的工具？

常见命令行与图形工具：

```text
命令行：jps, jstack, jmap, jstat, jinfo
图形化：jconsole, jvisualvm, Java Flight Recorder, Mission Control
```

- **jps**：列出正在运行的 JVM 进程
- **jstack**：线程堆栈分析（死锁、卡顿）
- **jmap**：生成 heap dump，查看对象分布
- **jstat**：查看 GC、类加载等统计信息
- **jinfo**：查看/修改 JVM 运行参数
- **jconsole / jvisualvm**：
  - 实时监控内存、线程、GC
  - 分析 CPU、内存使用
- **JFR / Mission Control**：
  - 低开销线上性能分析

---

## 15. 常用的 JVM 调优参数有哪些？

**内存相关：**
- `-Xms`：堆初始大小
- `-Xmx`：堆最大大小
- `-Xmn`：新生代大小
- `-XX:MetaspaceSize`、`-XX:MaxMetaspaceSize`
- `-Xss`：每个线程栈大小

**GC 相关：**
- `-XX:+UseSerialGC`
- `-XX:+UseParallelGC`
- `-XX:+UseConcMarkSweepGC`
- `-XX:+UseG1GC`
- `-XX:NewRatio`：新生代/老年代比例
- `-XX:SurvivorRatio`：Eden/Survivor 比例
- `-XX:MaxTenuringThreshold`：晋升阈值

**GC 日志：**
- `-XX:+PrintGC`
- `-XX:+PrintGCDetails`
- `-XX:+PrintGCDateStamps`
- `-Xlog:gc*`（JDK9+）

**诊断调试：**
- `-XX:+HeapDumpOnOutOfMemoryError`
- `-XX:HeapDumpPath=/path/xxx.hprof`
- `-XX:+PrintFlagsFinal`

---

## 16. 内存溢出、内存泄露、GC 的基本概念

**内存溢出（OutOfMemoryError, OOM）：**
- 程序需要的内存 > JVM 能提供的最大内存
- 常见场景：
  - 堆 OOM：大量对象无法回收
  - 元空间 OOM：大量动态生成类
  - 线程过多：栈空间不足

**内存泄露（Memory Leak）：**
- 对象不再使用，但仍然有引用指向
- 对 GC 来说仍是“可达”，无法回收
- 典型场景：
  - 静态集合不断累积对象
  - 监听器/回调未注销
  - ThreadLocal 使用不当

**GC 基本概念：**

```text
对象生命周期：
new -> 存活 -> (可达性变为不可达) -> 标记 -> 清除/整理
```

- GC 目标：
  - 自动管理堆内存
  - 回收不再使用的对象
- 关键点：
  - 可达性分析判定对象是否存活
  - 分代收集提高效率
  - 停顿时间 vs 吞吐量 的权衡

---

## 总结

- 建议将本文的示意图与 JVM 实际监控工具（jvisualvm、JFR 等）结合使用
- 面试时：
  - 先用**图**快速画出结构
  - 再围绕图解释概念和流程
  - 结合真实线上问题（Full GC、OOM、CMS 并发失败等）讲经验
