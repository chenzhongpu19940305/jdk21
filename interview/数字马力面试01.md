# 数字马力Java面试问到的题目

## 1. 聊聊你印象最深刻的项目？

**回答要点：**
- 选择一个真实且有技术深度的项目
- 说明项目的背景和业务意义
- 强调自己在项目中的核心贡献
- 讲述遇到的技术难点和解决方案
- 项目的成果和性能提升

---

## 2. 分布式锁加锁失败后的等待逻辑是如何实现的？

**回答要点：**
- 介绍常见的分布式锁实现方案（Redis、Zookeeper等）
- Redis分布式锁的实现：
  - 使用SET NX EX命令原子性加锁
  - 加锁失败后的重试机制（自旋、指数退避）
  - 使用Lua脚本保证解锁的原子性
- Zookeeper分布式锁的实现：
  - 临时有序节点
  - Watch机制监听前驱节点
  - 节点删除后自动唤醒等待线程
- 超时机制和异常处理

---

## 3. Netty相比原生的IO模型有啥优势？

**回答要点：**
- 原生IO模型的问题：
  - BIO：阻塞式IO，线程利用率低
  - NIO：需要手动管理Selector，代码复杂
  - AIO：实现复杂，系统支持不一致
- Netty的优势：
  - 基于事件驱动的异步非阻塞IO
  - 提供高性能的网络通信框架
  - 内置编解码器和协议支持
  - 零拷贝技术（DirectBuffer、FileRegion）
  - 线程模型优化（EventLoop、NioEventLoopGroup）
  - 开箱即用的SSL/TLS支持
  - 活跃的社区和完善的文档

---

## 4. 常见的索引结构有？哈希表结构属于哪种场景？

**回答要点：**
- 常见索引结构：
  - B树/B+树：范围查询、排序，适合磁盘存储
  - 哈希表：等值查询，O(1)时间复杂度
  - 跳表：有序数据结构，支持范围查询
  - 倒排索引：全文搜索
  - 位图索引：低基数列
- 哈希表的应用场景：
  - 等值查询场景（WHERE id = ?）
  - 不需要范围查询的情况
  - 内存数据库（Redis）
  - 缓存层
  - 哈希分区表

---

## 5. Redis里面lru、lfu缺点是什么？有什么解决的办法？

**回答要点：**
- LRU（Least Recently Used）缺点：
  - 无法区分访问频率
  - 一次访问就会更新，不能反映真实热度
  - 可能淘汰掉频繁使用但最近未访问的数据
- LFU（Least Frequently Used）缺点：
  - 实现复杂，内存开销大
  - 冷启动问题：新数据频率低容易被淘汰
  - 频率统计不准确
- 解决办法：
  - Redis 4.0+提供LFU模式，改进了频率计算
  - 使用概率衰减算法，定期降低访问频率
  - 结合TTL和LRU/LFU混合策略
  - 应用层面：预热热数据，合理设置过期时间
  - 使用多层缓存策略

---

## 6. Spring声明式事务原理？哪些场景事务会失效？

**回答要点：**
- 声明式事务原理：
  - 基于AOP代理实现
  - @Transactional注解标记事务方法
  - Spring在方法调用前后添加事务处理逻辑
  - 使用PlatformTransactionManager管理事务
- 事务失效的场景：
  - 方法不是public修饰符
  - 同类中调用（绕过代理）
  - 异常被捕获未抛出
  - 异常类型不匹配（默认只回滚RuntimeException）
  - 数据库不支持事务
  - 传播级别设置不当（PROPAGATION_NOT_SUPPORTED等）
  - 在非Spring容器管理的类中使用

---

## 7. 如果查询优化器选错了索引怎么办？

**回答要点：**
- 问题诊断：
  - 使用EXPLAIN分析执行计划
  - 检查索引的选择性和统计信息
- 解决方案：
  - 强制指定索引：FORCE INDEX、USE INDEX
  - 更新表统计信息：ANALYZE TABLE
  - 重建索引：DROP INDEX、CREATE INDEX
  - 调整查询语句，引导优化器选择正确索引
  - 添加更合适的索引
  - 考虑使用查询提示（Query Hint）
  - 定期维护索引，删除冗余索引

---

## 8. 请说一下你对分布式锁的理解，以及分布式锁的实现？

**回答要点：**
- 分布式锁的概念：
  - 在分布式系统中控制对共享资源的访问
  - 保证多个进程/节点的互斥性
  - 防止数据不一致和竞态条件
- 实现方式：
  - **Redis实现**：
    - SET key value NX EX timeout
    - Lua脚本保证原子性
    - 使用UUID防止误删
  - **Zookeeper实现**：
    - 临时有序节点
    - Watch机制
    - 节点删除触发唤醒
  - **数据库实现**：
    - 悲观锁（SELECT FOR UPDATE）
    - 乐观锁（版本号）
  - **Etcd实现**：
    - Lease机制
    - 事务支持
- 核心要素：
  - 互斥性
  - 防死锁（超时机制）
  - 高可用性
  - 高性能

---

## 9. Innodb的索引结构和myisam有区别吗？

**回答要点：**
- InnoDB索引结构：
  - 聚集索引（Clustered Index）：主键索引，叶子节点存储完整行数据
  - 二级索引（Secondary Index）：非主键索引，叶子节点存储主键值
  - 必须有主键，如果没有会自动创建
- MyISAM索引结构：
  - 非聚集索引：所有索引都是非聚集的
  - 叶子节点存储数据文件的物理地址（指针）
  - 主键索引和普通索引结构相同
- 区别：
  - InnoDB：回表查询，需要通过主键再查一次
  - MyISAM：直接通过指针访问数据
  - InnoDB支持事务，MyISAM不支持
  - InnoDB范围查询性能更好
  - MyISAM全表扫描性能更好

---

## 10. 说一说Mybatis里面的缓存机制？

**回答要点：**
- 一级缓存（Session级别）：
  - 默认开启，作用域为SqlSession
  - 同一个SqlSession中相同SQL只执行一次
  - SqlSession关闭时缓存清空
  - 增删改操作会清空缓存
- 二级缓存（Mapper级别）：
  - 需要显式配置开启
  - 作用域为Mapper，多个SqlSession共享
  - 需要实现Serializable接口
  - 支持自定义缓存实现（如Redis）
- 缓存失效场景：
  - 执行增删改操作
  - 手动调用clearCache()
  - 不同的SqlSession（一级缓存）
  - 配置了flushCache="true"
- 最佳实践：
  - 谨慎使用二级缓存
  - 考虑使用Redis替代Mybatis缓存
  - 关注缓存一致性问题

---

## 11. 架举noDB引擎的区别？请简要说明Mysql中My!!

**回答要点：**
- MySQL主要存储引擎对比：

| 特性 | InnoDB | MyISAM | Memory |
|------|--------|--------|--------|
| 事务支持 | 是 | 否 | 否 |
| 锁粒度 | 行级 | 表级 | 表级 |
| 外键支持 | 是 | 否 | 否 |
| 全文索引 | 5.6+ | 是 | 否 |
| 崩溃恢复 | 是 | 否 | 否 |
| 缓存 | 数据和索引 | 仅索引 | 内存 |

- InnoDB特点：
  - MySQL 5.5+默认引擎
  - 支持ACID事务
  - 行级锁，并发性能好
  - 支持外键约束
  - 自动故障恢复
  - 适合大多数应用场景

---

## 12. Java中的对象一定在堆上吗？

**回答要点：**
- 不一定，对象可能在栈上或被优化到寄存器
- 逃逸分析（Escape Analysis）：
  - JIT编译器分析对象的作用域
  - 如果对象不逃逸出方法，可以进行栈分配
  - 减少GC压力，提升性能
- 栈分配的条件：
  - 对象只在方法内使用
  - 不被其他线程访问
  - 不被返回或赋值给外部变量
- 标量替换：
  - 对象的字段直接分配在栈上
  - 避免对象的创建和销毁开销
- 实际应用：
  - 现代JVM（Java 6+）默认启用逃逸分析
  - 可通过-XX:+DoEscapeAnalysis启用
  - 对性能优化有显著帮助

---

## 13. 如果要你实现Spring IOC，你会注意哪些问题？

**回答要点：**
- 核心功能：
  - Bean的定义和注册
  - Bean的实例化和初始化
  - 依赖注入（构造器、Setter、字段）
  - Bean的生命周期管理
- 需要注意的问题：
  - **循环依赖**：
    - 构造器注入无法解决
    - Setter注入可通过三级缓存解决
  - **Bean的作用域**：
    - Singleton、Prototype、Request等
  - **初始化顺序**：
    - 处理Bean之间的依赖关系
  - **AOP集成**：
    - 代理对象的创建和管理
  - **扩展点**：
    - BeanPostProcessor、BeanFactoryPostProcessor
    - InitializingBean、DisposableBean接口
  - **性能优化**：
    - 缓存Bean定义
    - 延迟初始化
  - **线程安全**：
    - 并发创建Bean时的同步问题

---

## 14. Redis中多大的Key算热key，该如何解决？

**回答要点：**
- 热Key的定义：
  - 访问频率高的Key
  - 单位时间内访问次数超过阈值（如1000次/秒）
  - 可能导致Redis单点瓶颈
- 热Key的危害：
  - 单个Redis实例CPU占用率高
  - 网络带宽被占用
  - 影响其他Key的访问性能
  - 集群中可能导致某个节点过载
- 检测方法：
  - Redis MONITOR命令监控
  - 客户端统计访问频率
  - 使用Redis官方工具redis-cli --hotkeys
  - 应用层面统计和分析
- 解决方案：
  - **本地缓存**：在应用层使用Guava Cache、Caffeine
  - **多副本**：将热Key复制到多个Redis实例
  - **缓存预热**：启动时加载热Key到缓存
  - **限流**：对热Key的访问进行限流
  - **分散**：使用Key的变种（如添加随机后缀）分散访问
  - **CDN**：对热数据使用CDN缓存
  - **异步处理**：使用消息队列异步处理

---

## 15. ThreadLocal参数如何传递，线程池如何传递？

**回答要点：**
- ThreadLocal基本原理：
  - 每个线程独立的变量副本
  - Thread对象内部持有ThreadLocalMap
  - Key为ThreadLocal对象，Value为存储的值
- ThreadLocal的传递问题：
  - 同一线程内自动传递，无需显式处理
  - 线程切换时丢失（新线程没有该ThreadLocal值）
- 线程池中的传递方案：
  - **InheritableThreadLocal**：
    - 子线程继承父线程的ThreadLocal值
    - 线程池创建新线程时自动复制
    - 缺点：线程复用时值不会更新
  - **阿里开源方案（TransmittableThreadLocal）**：
    - 支持线程池中的值传递
    - 自动处理线程复用场景
    - 推荐在分布式追踪、链路追踪中使用
  - **手动传递**：
    - 在任务提交前保存ThreadLocal值
    - 在任务执行时恢复值
    - 任务执行完后清理
- 最佳实践：
  - 及时清理ThreadLocal，防止内存泄漏
  - 使用try-finally确保清理
  - 在线程池场景优先使用TransmittableThreadLocal

---

## 16. [线上问题排查]如果JVM出现频繁FullGC该如何解决？

**回答要点：**
- 问题诊断：
  - 使用jstat查看GC统计信息
  - 使用jmap生成堆快照分析
  - 使用jvisualvm或JProfiler可视化分析
  - 查看GC日志：-XX:+PrintGCDetails -XX:+PrintGCDateStamps
- 频繁FullGC的原因：
  - 堆内存设置过小
  - 内存泄漏导致老年代占满
  - 大对象频繁创建
  - 元空间溢出（PermGen或Metaspace）
  - 系统GC被显式调用
- 解决方案：
  - **调整堆大小**：
    - 增加-Xmx和-Xms
    - 保证Xms=Xmx避免动态扩展
  - **优化GC参数**：
    - 调整新生代和老年代比例
    - 选择合适的GC算法（G1GC、ZGC等）
  - **代码优化**：
    - 减少大对象创建
    - 优化对象生命周期
    - 使用对象池复用对象
  - **内存泄漏排查**：
    - 分析堆快照找出泄漏对象
    - 检查集合类是否及时清理
    - 检查监听器和回调是否注销
  - **元空间优化**：
    - 增加-XX:MetaspaceSize
    - 检查动态代理和反射的使用

---

## 17. 短URL生成器设计：百亿短URL怎样做到无冲突？

**回答要点：**
- 短URL的需求：
  - 将长URL映射为短URL
  - 支持反向查询（短URL还原为长URL）
  - 高并发、高可用
- 设计方案：
  - **方案一：哈希+冲突处理**：
    - 使用MD5或SHA-1对长URL哈希
    - 取哈希值的前N位作为短码
    - 冲突时添加后缀或重新哈希
    - 缺点：冲突处理复杂
  - **方案二：自增ID+进制转换**：
    - 使用数据库自增ID
    - 将ID转换为62进制（0-9, a-z, A-Z）
    - 优点：无冲突，性能高
    - 缺点：需要中心化ID生成服务
  - **方案三：分布式ID生成**：
    - 使用Snowflake算法生成全局唯一ID
    - 支持分布式部署
    - 转换为短码
- 存储设计：
  - **数据库**：
    - 长URL -> 短码映射表
    - 短码 -> 长URL映射表
    - 建立索引加速查询
  - **缓存**：
    - 热门短URL缓存到Redis
    - 减少数据库查询
  - **分片**：
    - 按短码哈希分片
    - 支持水平扩展
- 冲突避免：
  - 使用自增ID本质上无冲突
  - 定期清理过期数据
  - 监控短码使用情况

---

## 18. Kafka的消费者可能有哪些状态？Kafka的高水位是什么？

**回答要点：**
- Kafka消费者的状态：
  - **STABLE**：正常消费状态
  - **REBALANCING**：重新平衡中
  - **DEAD**：消费者已死亡
  - **EMPTY**：消费者组为空
- 消费者重新平衡（Rebalance）：
  - 触发条件：
    - 消费者加入或离开
    - 消费者超时
    - 订阅的Topic发生变化
  - 影响：
    - 短暂的消费停止
    - 可能导致重复消费或消息丢失
- Kafka高水位（High Water Mark, HWM）：
  - 定义：已被所有副本复制的最大消息偏移量
  - 作用：
    - 消费者只能消费到HWM之前的消息
    - 保证消息的可靠性
  - 与LEO的关系：
    - LEO（Log End Offset）：日志末尾偏移量
    - HWM <= LEO
  - 更新机制：
    - Leader定期更新HWM
    - 取所有副本LEO的最小值
- 消费者偏移量管理：
  - 自动提交：定期提交偏移量
  - 手动提交：显式调用commit()
  - 偏移量存储：Kafka内部Topic或Zookeeper

---

## 19. 和外部机构的API交互如何防止外部机构服务不可用拖垮调用服务？

**回答要点：**
- 问题分析：
  - 外部API响应慢或不可用
  - 导致调用线程堆积
  - 最终拖垮整个系统
- 防护方案：
  - **超时控制**：
    - 设置合理的连接超时和读超时
    - 避免无限等待
    - 建议：连接超时1-3秒，读超时5-10秒
  - **熔断器（Circuit Breaker）**：
    - 监控外部API调用失败率
    - 失败率超过阈值时打开熔断
    - 快速失败，返回降级结果
    - 定期尝试半开状态恢复
  - **限流（Rate Limiting）**：
    - 限制对外部API的请求速率
    - 防止过多请求堆积
    - 使用令牌桶或滑动窗口算法
  - **隔离（Isolation）**：
    - 使用独立的线程池处理外部API调用
    - 线程池满时快速拒绝
    - 防止占用业务线程
  - **降级（Degradation）**：
    - 外部API不可用时返回默认值
    - 使用本地缓存数据
    - 提供降级方案
  - **重试机制**：
    - 指数退避重试
    - 设置最大重试次数
    - 只对幂等操作重试
- 开源框架：
  - Hystrix：Netflix开源的熔断框架
  - Resilience4j：轻量级的容错库
  - Sentinel：阿里开源的流量防护框架

---

## 20. 如果让你实现一个dubbo，会考虑用那些技术解决哪些问题？

**回答要点：**
- Dubbo的核心功能：
  - RPC远程调用
  - 服务注册和发现
  - 负载均衡
  - 容错机制
  - 协议支持
- 技术选型：
  - **通信协议**：
    - Dubbo协议：二进制，高性能
    - HTTP/2：标准协议，易于跨语言
    - gRPC：Google开源，高性能
  - **序列化方案**：
    - Hessian：Dubbo默认
    - Protobuf：高效、跨语言
    - JSON：易于调试
  - **服务注册中心**：
    - Zookeeper：强一致性
    - Nacos：阿里开源，功能丰富
    - Eureka：Spring Cloud生态
  - **网络通信**：
    - Netty：高性能NIO框架
    - Mina：Apache开源
- 核心问题解决：
  - **服务发现**：
    - 服务提供者注册到注册中心
    - 消费者订阅服务变化
    - 动态更新可用服务列表
  - **负载均衡**：
    - 随机、轮询、最少活跃连接等策略
    - 权重支持
    - 动态调整
  - **容错机制**：
    - Failover：失败重试
    - Failfast：快速失败
    - Failsafe：失败安全
    - Failback：失败后台恢复
  - **超时和重试**：
    - 设置合理的超时时间
    - 指数退避重试
    - 最大重试次数限制
  - **线程模型**：
    - IO线程处理网络事件
    - 业务线程池处理业务逻辑
    - 避免线程阻塞
  - **监控和治理**：
    - 调用链追踪
    - 性能监控
    - 动态配置下发

---

## 21. 如果让你设计一个分布式链路追踪？你怎么做？

**回答要点：**
- 分布式链路追踪的目标：
  - 追踪请求在分布式系统中的完整路径
  - 定位性能瓶颈
  - 快速定位故障
- 核心设计：
  - **TraceID和SpanID**：
    - TraceID：全局唯一，标识一次完整请求
    - SpanID：局部唯一，标识一个操作单元
    - ParentSpanID：建立Span之间的父子关系
  - **数据采集**：
    - 在请求入口生成TraceID
    - 在每个服务间传递TraceID
    - 记录Span的开始时间、结束时间、耗时
    - 记录Span的标签、日志、异常信息
  - **数据存储**：
    - 使用时间序列数据库（如InfluxDB）
    - 或使用Elasticsearch存储Trace数据
    - 支持高吞吐量写入
  - **数据查询和展示**：
    - 按TraceID查询完整链路
    - 可视化展示调用关系
    - 支持性能分析和对比
- 技术方案：
  - **开源方案**：
    - Jaeger：CNCF开源，功能完整
    - Zipkin：Twitter开源，轻量级
    - SkyWalking：国内开源，功能丰富
  - **自研方案**：
    - 基于AOP或拦截器采集数据
    - 异步发送到收集服务
    - 使用消息队列缓冲数据
    - 后端处理和存储
- 关键问题：
  - **性能开销**：
    - 采样策略：不采集所有请求
    - 异步发送：不阻塞业务
    - 数据压缩：减少网络传输
  - **跨进程传递**：
    - HTTP Header传递TraceID
    - RPC框架集成
    - 消息队列集成
  - **数据一致性**：
    - 确保TraceID在整个链路中一致
    - 处理异步操作的追踪

---

## 22. [线上问题排查]数据库出现死锁如何排查

**回答要点：**
- 死锁的原因：
  - 多个事务相互等待对方释放的锁
  - 通常由于加锁顺序不一致导致
  - 长事务持有锁时间过长
- 死锁的检测：
  - MySQL自动检测死锁
  - 触发死锁时会回滚其中一个事务
  - 应用层捕获异常：Deadlock found when trying to get lock
- 排查方法：
  - **查看死锁日志**：
    - 启用死锁日志：innodb_print_all_deadlocks=ON
    - 查看MySQL错误日志
    - 分析死锁涉及的表和SQL
  - **使用命令查看**：
    - SHOW ENGINE INNODB STATUS：查看最近的死锁信息
    - 包含死锁涉及的事务、锁和SQL
  - **监控工具**：
    - 使用MySQL监控工具（如Percona）
    - 分析慢查询和锁等待
- 解决方案：
  - **优化SQL**：
    - 减少事务范围
    - 避免在事务中进行网络操作
    - 使用合适的索引减少锁定行数
  - **调整加锁顺序**：
    - 保证所有事务以相同的顺序加锁
    - 避免循环等待
  - **降低隔离级别**：
    - 从SERIALIZABLE降低到READ_COMMITTED
    - 减少锁的范围
  - **使用超时**：
    - 设置innodb_lock_wait_timeout
    - 避免无限等待
  - **优化业务逻辑**：
    - 避免长事务
    - 及时提交事务
    - 使用乐观锁替代悲观锁

---

## 23. 如果让你设计一个分布式链路跟踪系统？你怎么做？

**回答要点：**
- 系统架构：
  - **数据采集层**：
    - 在应用中埋点采集Trace数据
    - 使用Agent或SDK方式
    - 支持多种框架集成
  - **数据传输层**：
    - 异步发送数据到收集服务
    - 使用消息队列缓冲
    - 支持批量发送提高效率
  - **数据存储层**：
    - 使用时间序列数据库或搜索引擎
    - 支持高吞吐量写入
    - 支持快速查询
  - **查询和展示层**：
    - Web UI展示链路信息
    - 支持按TraceID、服务、时间范围查询
    - 可视化展示调用关系和性能指标
- 核心功能：
  - **链路追踪**：
    - 完整展示请求的调用链路
    - 显示各个Span的耗时
    - 标识性能瓶颈
  - **性能分析**：
    - 统计各个服务的平均响应时间
    - 分析慢查询
    - 对比不同时间段的性能
  - **故障定位**：
    - 快速定位异常服务
    - 显示异常堆栈信息
    - 关联日志和Metrics
  - **依赖分析**：
    - 自动生成服务依赖图
    - 分析服务间的调用关系
    - 识别关键路径
- 技术选型：
  - **数据采集**：
    - 使用OpenTelemetry标准
    - 支持多种语言和框架
  - **存储**：
    - Elasticsearch：支持全文搜索
    - ClickHouse：列式存储，查询快
    - Cassandra：分布式存储
  - **展示**：
    - Grafana：可视化展示
    - 自研Web UI
- 性能优化：
  - **采样策略**：
    - 头部采样：在请求入口决定是否采样
    - 尾部采样：根据采样结果决定
    - 自适应采样：根据系统负载动态调整
  - **数据压缩**：
    - 使用高效的序列化格式
    - 压缩传输数据
  - **查询优化**：
    - 建立合适的索引
    - 使用缓存加速查询

---

## 24. 如何设计RPC框架在10万OPS下实现毫秒级的服务调用？

**回答要点：**
- 性能目标：
  - 10万OPS（Operations Per Second）
  - 毫秒级延迟（P99 < 10ms）
  - 高可用性
- 核心设计：
  - **高效的网络通信**：
    - 使用Netty实现异步NIO
    - 连接复用，减少连接建立开销
    - 使用DirectBuffer减少GC
    - 支持HTTP/2多路复用
  - **高效的序列化**：
    - 使用Protobuf或Thrift
    - 避免使用Java序列化
    - 支持零拷贝
  - **连接管理**：
    - 连接池管理
    - 心跳检测
    - 自动重连
    - 连接预热
  - **线程模型**：
    - IO线程和业务线程分离
    - 使用线程池处理业务逻辑
    - 避免线程上下文切换
    - 使用虚拟线程（Java 19+）
- 性能优化：
  - **缓存优化**：
    - 本地缓存热点数据
    - 减少远程调用
  - **批处理**：
    - 支持批量请求
    - 减少网络往返次数
  - **异步处理**：
    - 异步调用，不阻塞业务线程
    - 使用CompletableFuture处理异步结果
  - **负载均衡**：
    - 智能路由，选择最优节点
    - 考虑节点负载和延迟
    - 支持权重调整
- 可靠性保证：
  - **超时控制**：
    - 设置合理的超时时间
    - 避免无限等待
  - **重试机制**：
    - 指数退避重试
    - 只对幂等操作重试
  - **熔断降级**：
    - 监控调用失败率
    - 快速失败，返回降级结果
  - **监控告警**：
    - 实时监控性能指标
    - 及时发现和处理问题
- 监控指标：
  - 吞吐量（QPS）
  - 延迟（P50、P95、P99）
  - 错误率
  - 可用性

---

## 补充资源

- 推荐阅读：
  - 《深入理解Java虚拟机》
  - 《高性能MySQL》
  - 《分布式系统设计》
  - 《微服务架构设计》
  - Redis官方文档
  - Spring Framework源码
  - Kafka官方文档

- 学习建议：
  - 深入理解原理，不要只记住结论
  - 结合实际项目经验讲述
  - 准备具体的代码示例
  - 了解性能优化的trade-off
  - 关注开源项目的实现细节
