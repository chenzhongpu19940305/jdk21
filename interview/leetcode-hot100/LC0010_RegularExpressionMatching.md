# LC0010 正则表达式匹配（Regular Expression Matching）

## 题目大意
实现支持 `.` 和 `*` 的正则匹配：
- `.` 匹配任意单个字符。
- `*` 匹配零个或多个前面的那个元素。
匹配需要覆盖 **整个** 字符串，而不是部分匹配。

## 思路（动态规划）
- 定义 `dp[i][j]`：表示 `s[0..i-1]` 与 `p[0..j-1]` 是否匹配。
- 转移：
  - 若 `p[j-1] != '*'`：
    - 需当前字符能匹配：`s[i-1] == p[j-1]` 或 `p[j-1] == '.'`。
    - 且前缀匹配：`dp[i][j] = dp[i-1][j-1]`。
  - 若 `p[j-1] == '*'`：分两种情况：
    - `*` 表示前一个字符出现 **0 次**：`dp[i][j] |= dp[i][j-2]`。
    - `*` 表示前一个字符出现 **1 次以上**：
      - 要求前一个字符 `p[j-2]` 能匹配 `s[i-1]`（相同或为 `.`）。
      - 匹配一个后，继续看 `dp[i-1][j]`。
- 边界：
  - 空串与空模式匹配：`dp[0][0] = true`。
  - 处理前缀是 `a*`, `a*b*` 这类可以匹配空串的情况。

## 复杂度
- 时间复杂度：O(mn)，m 为 `s` 长度，n 为 `p` 长度。
- 空间复杂度：O(mn)。

## 考点
- **二维动态规划状态设计**。
- `*` 的两种含义（0 次 / 多次）如何合并到转移中。
- 边界情况：空串、以 `*` 结尾、连续多个 `*` 等。
