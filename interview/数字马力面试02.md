# 数字马力Java面试三面 - 项目深度讨论

## 开场问题

### 1. 所有的项目都过了一遍，问了一下细节

**回答要点：**
- 项目经历的完整梳理：
  - 按时间顺序介绍主要项目
  - 每个项目的规模、技术栈、团队规模
  - 自己在项目中的角色和贡献
- 细节讨论的准备：
  - 深入了解项目的架构设计
  - 掌握核心业务逻辑
  - 能够讲述技术决策的原因
  - 准备具体的代码示例
- 常见的细节问题：
  - 项目的瓶颈和优化方案
  - 遇到的难题和解决方案
  - 项目中的失败案例和教训
  - 如何衡量项目的成功
- 回答技巧：
  - 突出自己的核心贡献
  - 展示技术深度和广度
  - 说明项目对业务的影响
  - 体现学习和成长

---

## 2. 数据迁移过程，TIDB数据迁移到MySQL的全过程？双读双写怎么做的

**回答要点：**
- 数据迁移的背景和目标：
  - 为什么从TIDB迁移到MySQL
  - 迁移的时间窗口和影响范围
  - 迁移的成功标准
- 迁移方案设计：
  - **全量迁移阶段**：
    - 使用数据库导出工具（mysqldump、DataX等）
    - 批量导入到目标MySQL
    - 验证数据完整性和一致性
  - **增量迁移阶段**：
    - 使用TIDB的binlog或CDC工具
    - 实时同步增量数据到MySQL
    - 处理冲突和重复数据
- 双读双写的实现：
  - **架构设计**：
    - 应用层同时读写TIDB和MySQL
    - 使用数据访问层（DAO）统一管理
    - 配置开关控制读写比例
  - **实现方式**：
    - 写操作：同时写入TIDB和MySQL
    - 读操作：优先读MySQL，失败回退到TIDB
    - 或者按比例分流读请求
  - **数据一致性保证**：
    - 写入时使用事务保证原子性
    - 定期对账检查数据一致性
    - 发现不一致时进行修复
  - **灰度策略**：
    - 先在小流量业务上验证
    - 逐步增加MySQL的读写比例
    - 监控性能和错误率
- 风险控制：
  - **回滚方案**：
    - 保持TIDB的完整数据
    - 如果出现问题快速回滚到TIDB
    - 准备好回滚脚本
  - **监控告警**：
    - 监控两个数据库的数据一致性
    - 监控性能指标
    - 及时发现和处理问题
  - **验证方案**：
    - 定期全量对账
    - 抽样验证数据正确性
    - 业务逻辑验证

---

## 3. Java线程和操作系统线程的区别

**回答要点：**
- 操作系统线程：
  - 由操作系统内核管理
  - 真正的并行执行（多核CPU）
  - 上下文切换开销大
  - 创建和销毁成本高
  - 线程数量受限于系统资源
- Java线程：
  - JVM层面的抽象
  - 一对一映射到操作系统线程（HotSpot JVM）
  - 由JVM调度管理
  - 跨平台，屏蔽操作系统差异
- 关键区别：
  - **创建方式**：
    - 操作系统线程：系统调用创建
    - Java线程：new Thread()创建，JVM负责映射
  - **调度**：
    - 操作系统线程：由内核调度器管理
    - Java线程：由JVM调度器管理
  - **上下文切换**：
    - 操作系统线程：内核级上下文切换
    - Java线程：可能涉及用户态和内核态切换
  - **内存占用**：
    - 操作系统线程：通常1-8MB
    - Java线程：约1MB（包括栈空间）
  - **线程本地存储**：
    - 操作系统线程：TLS（Thread Local Storage）
    - Java线程：ThreadLocal机制
- Java虚拟线程（Virtual Threads, Java 19+）：
  - 轻量级线程，不一对一映射到OS线程
  - 由JVM调度，可创建百万级虚拟线程
  - 大幅降低线程创建和切换成本
  - 简化异步编程模型

---

## 4. Java线程和操作系统线程的区别

**回答要点：**
（同第3题，可补充以下内容）
- 线程栈的区别：
  - 操作系统线程：栈由内核管理
  - Java线程：栈大小可配置（-Xss参数）
  - 默认栈大小：1MB（可调整）
- 线程安全性：
  - 操作系统线程：原子操作由CPU指令支持
  - Java线程：synchronized、volatile等机制
  - 内存可见性：Java内存模型保证
- 性能考虑：
  - 线程数量：OS线程受限，Java虚拟线程无限制
  - 上下文切换：OS线程成本高，虚拟线程成本低
  - 缓存亲和性：线程绑定到CPU核心可提升性能

---

## 5. 线程和线程池的生命周期

**回答要点：**
- 线程的生命周期：
  - **NEW**：线程创建但未启动
  - **RUNNABLE**：线程可运行状态（包括运行和就绪）
  - **BLOCKED**：线程等待监视器锁
  - **WAITING**：线程无限期等待（wait()、join()）
  - **TIMED_WAITING**：线程有时限等待（sleep()、wait(timeout)）
  - **TERMINATED**：线程执行完毕
- 线程池的生命周期：
  - **RUNNING**：线程池正常运行
  - **SHUTDOWN**：调用shutdown()，不接受新任务，等待现有任务完成
  - **STOP**：调用shutdownNow()，停止所有任务
  - **TIDYING**：所有任务完成，线程数为0
  - **TERMINATED**：terminated()方法执行完毕
- 线程池的核心参数：
  - corePoolSize：核心线程数
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程空闲时间
  - workQueue：任务队列
  - rejectionPolicy：拒绝策略
- 线程池的工作流程：
  - 任务提交 -> 核心线程处理
  - 核心线程满 -> 加入队列
  - 队列满 -> 创建新线程
  - 线程数达到最大 -> 执行拒绝策略
- 优雅关闭：
  - shutdown()：等待所有任务完成
  - awaitTermination()：等待指定时间
  - shutdownNow()：立即停止（可能丢失任务）

---

## 6. MQ熟悉哪几个？rabbitmq和其他mq的区别？他们都是怎么保证消息的顺序？

**回答要点：**
- 常见的MQ产品：
  - **RabbitMQ**：AMQP协议，功能完整
  - **Kafka**：高吞吐量，分布式
  - **RocketMQ**：阿里开源，功能丰富
  - **ActiveMQ**：Apache开源，功能全面
  - **Pulsar**：云原生，多租户
- RabbitMQ的特点：
  - 基于AMQP协议
  - 功能完整：交换机、队列、绑定
  - 可靠性高：支持事务和持久化
  - 性能中等：吞吐量不如Kafka
  - 部署复杂：需要Erlang运行时
- RabbitMQ vs 其他MQ：
  - vs Kafka：
    - RabbitMQ：功能完整，可靠性高，性能一般
    - Kafka：高吞吐量，分布式，功能简单
  - vs RocketMQ：
    - RabbitMQ：成熟稳定，社区活跃
    - RocketMQ：功能丰富，性能好，国内支持好
  - vs ActiveMQ：
    - RabbitMQ：更轻量，性能更好
    - ActiveMQ：功能全面，但性能一般
- 消息顺序保证：
  - **RabbitMQ**：
    - 单队列单消费者：天然顺序
    - 多消费者：使用优先级队列或单队列单消费者
    - 关键：避免并发消费同一队列
  - **Kafka**：
    - 分区内有序：同一分区内消息有序
    - 单分区单消费者：保证顺序
    - 实现：按业务Key分区，保证同一Key的消息到同一分区
  - **RocketMQ**：
    - 顺序消息：使用MessageQueueSelector
    - 同一队列单消费者：保证顺序
    - 实现：按业务Key选择队列
- 顺序保证的通用方案：
  - **分区/队列设计**：
    - 按业务维度分区（如用户ID、订单ID）
    - 同一维度的消息到同一分区/队列
  - **消费端**：
    - 单线程消费
    - 或使用锁保证顺序
  - **生产端**：
    - 按Key发送到同一分区
    - 等待前一条消息发送成功再发送下一条

---

## 7. 你知道java有哪几种锁？cas原理是什么？aba问题怎么解决呢

**回答要点：**
- Java中的锁分类：
  - **悲观锁**：
    - synchronized：JVM内置，重量级锁
    - ReentrantLock：可重入锁，支持公平/非公平
    - ReadWriteLock：读写锁
  - **乐观锁**：
    - CAS（Compare And Swap）
    - 版本号机制
  - **按粒度分**：
    - 对象锁：synchronized(obj)
    - 类锁：synchronized(Class)
    - 方法锁：synchronized修饰方法
  - **按性质分**：
    - 可重入锁：同一线程可多次获取
    - 不可重入锁：不支持重入
    - 公平锁：按FIFO顺序获取
    - 非公平锁：随机获取
  - **按状态分**：
    - 偏向锁：无竞争时的优化
    - 轻量级锁：少量竞争
    - 重量级锁：高度竞争
- CAS原理：
  - **定义**：Compare And Swap
  - **操作**：
    - 比较内存中的值与期望值
    - 如果相等，更新为新值
    - 如果不相等，返回失败
  - **原子性**：
    - 由CPU指令保证（cmpxchg）
    - 不需要加锁
  - **实现**：
    - Java中通过Unsafe类实现
    - AtomicInteger、AtomicLong等原子类使用CAS
  - **优点**：
    - 无锁，性能高
    - 不会导致线程阻塞
  - **缺点**：
    - 自旋等待，CPU占用率高
    - ABA问题
    - 只能保证单个变量的原子性
- ABA问题：
  - **问题描述**：
    - 线程A读取值为A
    - 线程B将值改为B，再改回A
    - 线程A的CAS操作成功，但实际值已被修改
  - **危害**：
    - 可能导致数据不一致
    - 特别是在链表等数据结构中
  - **解决方案**：
    - **版本号**：
      - 每次修改时增加版本号
      - CAS时同时比较值和版本号
      - Java中的AtomicStampedReference
    - **时间戳**：
      - 记录修改时间
      - 检查时间戳是否变化
    - **AtomicMarkableReference**：
      - 使用布尔标记代替版本号
      - 适用于二元状态
- CAS的应用：
  - 原子类：AtomicInteger、AtomicLong等
  - 并发集合：ConcurrentHashMap、CopyOnWriteArrayList
  - 锁实现：ReentrantLock基于AQS，使用CAS更新状态

---

## 8. 你们怎么做的分库分表？为什么要这样做分库分表？

**回答要点：**
- 分库分表的目标：
  - 解决单表数据量过大的问题
  - 提升数据库的并发处理能力
  - 降低单个数据库的压力
  - 支持业务的水平扩展
- 分库分表的必要性：
  - **单表瓶颈**：
    - 单表数据量过大（>1000万行）
    - 索引效率下降
    - 查询性能下降
  - **并发瓶颈**：
    - 单个数据库连接数有限
    - 单个数据库CPU和内存有限
    - 需要分散并发压力
  - **业务需求**：
    - 支持业务快速增长
    - 支持多地域部署
    - 支持多租户隔离
- 分库分表的方案：
  - **分表**：
    - 按时间分表：按月、按天分表
    - 按ID分表：按用户ID、订单ID等哈希分表
    - 按业务分表：按业务维度分表
  - **分库**：
    - 按用户维度分库
    - 按业务维度分库
    - 按地域维度分库
  - **分库分表结合**：
    - 先分库再分表
    - 分库数 = 总数据量 / 单库容量
    - 分表数 = 单库数据量 / 单表容量
- 分库分表的实现：
  - **路由算法**：
    - 哈希取模：hash(key) % N
    - 一致性哈希：支持动态扩容
    - 范围分片：按ID范围分片
  - **中间件方案**：
    - ShardingSphere：功能完整，支持多种分片策略
    - MyCat：轻量级，易于部署
    - Cobar：阿里开源
  - **应用层方案**：
    - 在应用层实现分片逻辑
    - 优点：灵活，可控
    - 缺点：需要在应用层处理
- 分库分表的挑战：
  - **跨库查询**：
    - 无法使用JOIN
    - 需要在应用层进行关联
    - 性能下降
  - **分布式事务**：
    - 无法使用本地事务
    - 需要使用分布式事务方案
    - 性能和复杂度增加
  - **全局唯一ID**：
    - 无法使用数据库自增ID
    - 需要使用分布式ID生成方案（Snowflake等）
  - **扩容困难**：
    - 增加分片数需要数据迁移
    - 迁移过程复杂，风险大
- 最佳实践：
  - **选择合适的分片键**：
    - 选择高基数的字段
    - 避免热点数据集中
    - 支持业务查询需求
  - **合理设置分片数**：
    - 预留扩容空间
    - 避免过度分片
    - 考虑维护成本
  - **监控和告警**：
    - 监控各分片的数据量
    - 监控查询性能
    - 及时发现和处理问题
  - **文档和培训**：
    - 记录分片策略
    - 培训团队成员
    - 建立应急预案

---

## 补充资源

- 推荐阅读：
  - 《深入理解Java虚拟机》
  - 《Java并发编程实战》
  - 《高性能MySQL》
  - 《分布式系统设计》
  - ShardingSphere官方文档
  - Kafka官方文档

- 学习建议：
  - 深入理解分布式系统的核心概念
  - 掌握常见的分布式问题和解决方案
  - 结合实际项目经验讲述
  - 准备具体的代码示例和架构图
  - 了解不同方案的trade-off
