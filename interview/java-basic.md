本文档用于整理常见 Java 面试题及答案，由 AI 辅助生成。

## 1. 说说静态变量和非静态变量的区别，用类名调用静态变量和用实例对象调用静态变量有区别吗？

### 答案

1. **概念与生命周期**
   - 静态变量（类变量）：用 `static` 修饰，属于「类」，类加载时分配一次内存，直到类卸载才回收，所有实例共享一份数据。
   - 非静态变量（实例变量）：不加 `static`，属于「对象」，每创建一个实例就有一份，随对象创建/回收。

2. **内存与访问方式**
   - 静态变量：逻辑上跟随类元数据存在，通过 `类名.变量名` 访问即可，不依赖具体对象。
   - 实例变量：存储在具体对象的内存中，必须先 `new` 出对象，再通过 `对象.变量名` 访问。

3. **共享性与线程安全**
   - 静态变量：所有线程、所有实例共享，适合做全局配置、缓存、计数器等，但并发场景下需要考虑同步/原子操作。
   - 实例变量：每个对象独立，天然隔离，不同实例之间互不影响。

4. **用类名调用静态变量 vs 用实例对象调用静态变量**
   - 语法上两种都可以，例如：

   ```java
   public class User {
       public static int onlineCount = 0; // 静态变量
       public int age;                    // 实例变量
   }

   User u = new User();
   User.onlineCount++;   // 推荐写法
   u.onlineCount++;      // 语法允许，但不推荐
   ```

   - **本质上没有区别**：编译器会根据变量的静态性质，直接解析为 `User.onlineCount`，不会跟 `u` 这个实例绑定。
   - 但从可读性和规范性上：
     - 推荐始终用 `类名.静态变量` 的方式；
     - 用对象访问容易误导阅读者，以为每个对象有一份，甚至在父子类有同名静态变量时，引入「按引用声明类型解析」的困惑。

---

## 2. 非静态方法里可以有静态变量吗？

### 答案

1. **不能在方法体内部声明静态局部变量**
   - Java 语法不允许在普通方法体内写：

   ```java
   public void test() {
       static int x = 0; // 编译错误：Illegal start of expression
   }
   ```

   - `static` 只能修饰**类成员**（静态变量、静态方法、静态代码块、静态内部类），不能修饰方法内部的局部变量。
   - 局部变量生命周期只存在于一次方法调用的栈帧中；静态变量则要求「类级别唯一一份」，语言设计上不支持这种混用。

2. **非静态方法可以访问类的静态变量**
   - 虽然方法里不能声明静态局部变量，但可以在非静态方法内访问类的静态成员：

   ```java
   public class Counter {
       private static int total = 0; // 静态变量

       private int id;               // 实例变量

       public Counter() {
           total++;       // 在构造方法(非静态)里访问静态变量
           this.id = total;
       }

       public void print() { // 非静态方法
           System.out.println("id = " + id + ", total = " + total);
       }
   }
   ```

   - 非静态方法既能访问「实例成员」(`id`)，也能访问「静态成员」(`total`)，因为此时既有 `this` 对象，又有类信息。

3. **面试总结说法**
   - 明确回答：**方法内部不能再声明 static 变量**，只能在类级别定义静态变量；
   - 补充：非静态方法内可以读写类的静态变量，这在统计实例个数、共享配置等场景非常常见。


## 1. Java 堆栈区别：java 内存模型堆内存还有栈内存有什么区别？

**答：**

- **栈（Stack）**
   - 存放：方法调用栈帧、局部变量、方法参数、引用变量等。
   - 生命周期：线程启动创建栈，线程结束栈销毁；方法调用入栈、返回出栈，自动回收。
   - 特点：
      - 线程私有，线程安全。
      - 空间较小，访问速度快。
      - 栈帧过深会 `StackOverflowError`。

- **堆（Heap）**
   - 存放：所有 `new` 出来的对象及其实例字段。
   - 生命周期：对象只要有引用链可达就不会被回收，不可达时由 GC 回收。
   - 特点：
      - 所有线程共享。
      - 空间大，需要垃圾回收器管理，频繁分配/回收会有 GC 开销。
      - 内存不足会 `OutOfMemoryError`。

> 总结：  
> 栈存「方法执行时的临时数据」，线程私有，自动回收，快。  
> 堆存「对象实例」，线程共享，需要 GC 管理，空间大但相对慢。

---

## 2. Full GC 处理：GC 的定义、什么情况下出现 Full GC？程序出现 FGC 的处理思路？

**答：**

### 2.1 GC 的定义

GC（Garbage Collection）是 JVM 自动回收**不再被引用**对象的机制。  
典型分代：新生代（Young）、老年代（Old）、元空间（Metaspace）。

- Minor GC：回收新生代。
- Major/Old GC：回收老年代。
- **Full GC**：对整个堆（新生代 + 老年代 + 元空间）做一次回收，停顿时间最长。

---

### 2.2 一般什么情况下会出现 Full GC？

常见触发原因：

1. **老年代空间不足**
   - 新生代晋升对象时老年代放不下，触发 Full GC。
2. **元空间不足**
   - 大量动态加载类导致元空间快满。
3. **显式调用 `System.gc()` / `Runtime.getRuntime().gc()`**
   - 默认配置下通常会触发 Full GC。
4. **CMS / G1 等 GC 失败**
   - 如 CMS 的 Concurrent Mode Failure、G1 无法回收足够空间。
5. **大对象直接进入老年代导致老年代瞬间吃满**。

---

### 2.3 程序出现频繁 Full GC 的排查思路

1. **先确认 GC 情况**
   - 打 GC 日志：
      - JDK8：`-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log`
      - JDK9+：`-Xlog:gc*:file=gc.log`
   - 观察 Full GC 次数、间隔、停顿时间，老年代/元空间使用情况。

2. **判断是内存泄漏还是内存真的不够**
   - Full GC 后老年代占用仍然很高且持续上涨 → 怀疑**内存泄漏**或对象生命周期异常长。
   - Full GC 后能回收很多，但 Full GC 很频繁 → 可能是**堆太小**或对象创建过于集中。

3. **定位大对象和长生命周期对象**
   - 使用 `jmap -histo`、MAT、VisualVM 等工具。
   - 重点关注：
      - 大集合（List/Map）是否不断增长；
      - 缓存是否无上限或不过期；
      - 静态集合、单例中是否存了大量数据；
      - ThreadLocal 是否泄漏。

4. **检查代码习惯**
   - 是否在业务代码中滥用 `System.gc()`。
   - 是否频繁创建大对象/大数组。
   - 是否有一口气把大量数据（如读全表）加载进内存的逻辑。
   - 缓存策略是否合理。

5. **参数和架构优化**
   - 合理设置堆大小：`-Xms`、`-Xmx`，以及新生代大小。
   - 根据业务特性选择合适的 GC（Parallel / CMS / G1 / ZGC 等）。
   - 给缓存加容量限制和过期策略。
   - 确认是否需要扩容/拆分服务来降低单机压力。

---

## 3. 线程池参数：线程池参数有哪些？IO 密集/CPU 密集程序线程数怎么设置？

**答：**

### 3.1 线程池主要参数（以 ThreadPoolExecutor 为例）

```java
ThreadPoolExecutor(
    int corePoolSize,               // 核心线程数
    int maximumPoolSize,            // 最大线程数
    long keepAliveTime,             // 非核心线程空闲存活时间
    TimeUnit unit,                  // 上面时间的单位
    BlockingQueue<Runnable> workQueue, // 任务队列
    ThreadFactory threadFactory,       // 线程工厂（命名、是否守护线程等）
    RejectedExecutionHandler handler   // 拒绝策略
)

