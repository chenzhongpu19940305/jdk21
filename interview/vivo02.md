# vivo面试题汇总（第二套）

## 1. 如果系统接口响应比较慢,你会从哪些方面排查?

**回答要点：**
- **应用层排查**：
  - 查看应用日志，定位慢接口和异常堆栈
  - 分析代码逻辑，检查是否有性能瓶颈
  - 检查是否有死锁、线程阻塞
  - 使用APM工具（如SkyWalking、Pinpoint）分析调用链
- **数据库层排查**：
  - 检查慢SQL日志，分析执行计划
  - 查看数据库连接池使用情况
  - 检查是否有锁等待、死锁
  - 分析索引使用情况，是否存在索引失效
  - 查看数据库CPU、IO使用率
- **缓存层排查**：
  - 检查缓存命中率
  - 查看Redis连接数和响应时间
  - 分析是否有缓存穿透、击穿、雪崩
  - 检查缓存数据是否过大
- **网络层排查**：
  - 检查网络延迟和带宽使用
  - 查看DNS解析时间
  - 分析CDN和负载均衡配置
  - 检查是否有网络丢包
- **系统资源排查**：
  - 查看CPU使用率和负载
  - 检查内存使用情况，是否有内存泄漏
  - 分析磁盘IO性能
  - 查看GC日志，分析GC频率和耗时
- **排查工具**：
  - `top`、`htop`：查看系统资源
  - `jstack`：查看线程堆栈
  - `jmap`：查看内存使用
  - `jstat`：查看GC情况
  - `tcpdump`、`wireshark`：网络抓包
  - `strace`：系统调用追踪

---

## 2. 项目中如何使用支付,支付处理失败怎么办?

**回答要点：**
- **支付集成方式**：
  - 对接第三方支付平台（支付宝、微信、银联等）
  - 使用支付SDK或API接口
  - 实现支付回调处理
- **支付流程**：
  1. 用户提交订单，生成支付订单
  2. 调用支付接口，获取支付链接或二维码
  3. 用户完成支付
  4. 支付平台回调通知
  5. 验证回调签名，更新订单状态
  6. 返回支付结果给用户
- **支付失败处理**：
  - **重试机制**：
    - 支付接口调用失败时重试
    - 使用指数退避策略
    - 设置最大重试次数
  - **异步处理**：
    - 支付结果通过异步回调处理
    - 使用消息队列保证可靠性
    - 支持手动补单
  - **状态管理**：
    - 订单状态：待支付、支付中、已支付、支付失败、已取消
    - 支付状态与订单状态解耦
    - 支持状态查询和同步
  - **补偿机制**：
    - 定时任务查询支付状态
    - 对长时间未回调的订单主动查询
    - 处理异常订单（支付成功但未回调）
  - **对账机制**：
    - 每日与支付平台对账
    - 发现差异及时处理
    - 保证数据一致性
- **安全性考虑**：
  - 验证回调签名，防止伪造
  - 幂等性处理，防止重复支付
  - 金额校验，防止篡改
  - 敏感信息加密传输

---

## 3. java中的锁介绍一下,死锁一般是怎么导致的?

**回答要点：**
- **Java锁的分类**：
  - **synchronized**：
    - 内置锁，JVM层面实现
    - 可重入锁
    - 非公平锁
    - 支持方法锁和代码块锁
  - **ReentrantLock**：
    - 显式锁，API层面实现
    - 可重入锁
    - 支持公平锁和非公平锁
    - 支持中断和超时
  - **ReadWriteLock**：
    - 读写分离锁
    - 读锁共享，写锁独占
    - 提高读多写少场景性能
  - **StampedLock**：
    - JDK 8新增，支持乐观读
    - 性能优于ReadWriteLock
- **锁的优化**：
  - 锁粗化：减少锁的获取和释放次数
  - 锁消除：JVM优化，去除不必要的锁
  - 偏向锁、轻量级锁、重量级锁升级
- **死锁的定义**：
  - 两个或多个线程相互等待对方释放锁
  - 导致所有线程都无法继续执行
- **死锁产生的条件**（四个必要条件）：
  1. **互斥条件**：资源不能被多个线程同时使用
  2. **请求与保持**：持有资源的同时请求新资源
  3. **不可剥夺**：已获得的资源不能被强制释放
  4. **循环等待**：存在循环等待链
- **死锁的常见场景**：
  - **锁顺序不一致**：
    ```java
    // 线程1：先锁A后锁B
    // 线程2：先锁B后锁A
    // 可能导致死锁
    ```
  - **嵌套锁**：方法间相互调用，锁的嵌套使用
  - **资源竞争**：多个线程竞争同一组资源
- **死锁的预防**：
  - 统一锁的获取顺序
  - 使用超时锁（tryLock with timeout）
  - 避免嵌套锁
  - 使用锁的层次结构
- **死锁的检测和排查**：
  - `jstack`查看线程堆栈
  - `jconsole`可视化监控
  - 分析线程状态和锁持有情况
  - 使用死锁检测工具

---

## 4. 项目中的滑动窗口控制流量是如何实现的?

**回答要点：**
- **滑动窗口算法原理**：
  - 将时间划分为多个时间窗口
  - 每个窗口维护请求计数
  - 滑动窗口在时间轴上移动
  - 统计窗口内总请求数，超过阈值则限流
- **实现方式**：
  - **基于Redis实现**：
    ```java
    // 使用Redis的ZSet实现滑动窗口
    // key: 限流key，score: 时间戳，value: 请求标识
    // 每次请求：添加当前时间戳，删除过期时间戳
    // 统计窗口内元素数量
    ```
  - **基于本地缓存实现**：
    - 使用循环数组或队列
    - 维护时间窗口内的请求记录
    - 适合单机限流
  - **基于令牌桶/漏桶**：
    - 令牌桶：按固定速率生成令牌
    - 漏桶：固定速率处理请求
    - 支持突发流量
- **滑动窗口 vs 固定窗口**：
  - 固定窗口：边界处可能出现流量突增
  - 滑动窗口：更平滑，更精确控制
- **关键参数**：
  - 窗口大小：时间窗口长度（如1秒、1分钟）
  - 窗口数量：滑动窗口的窗口数
  - 限流阈值：每个窗口允许的最大请求数
- **实现细节**：
  - 时间精度：毫秒级或秒级
  - 原子操作：使用Lua脚本保证原子性
  - 性能优化：批量删除过期数据
  - 分布式支持：使用Redis实现分布式限流
- **应用场景**：
  - API限流
  - 接口QPS控制
  - 防止恶意请求
  - 保护下游服务

---

## 5. 系统服务出现问题一般怎么排查,什么命令还是工具?

**回答要点：**
- **问题分类**：
  - 性能问题：响应慢、CPU高、内存泄漏
  - 功能问题：接口异常、数据错误
  - 可用性问题：服务不可用、频繁重启
- **排查步骤**：
  1. **查看日志**：
     - 应用日志：定位错误堆栈
     - 系统日志：`/var/log/messages`
     - 容器日志：`docker logs`
  2. **监控指标**：
     - CPU、内存、磁盘、网络使用率
     - QPS、响应时间、错误率
     - 线程数、连接数
  3. **线程分析**：
     - `jstack <pid>`：查看线程堆栈
     - 分析线程状态：RUNNABLE、BLOCKED、WAITING
     - 查找死锁和线程阻塞
  4. **内存分析**：
     - `jmap -heap <pid>`：查看堆内存
     - `jmap -dump`：生成堆快照
     - `jhat`、`MAT`：分析内存泄漏
  5. **GC分析**：
     - `jstat -gc <pid>`：查看GC统计
     - 分析GC频率和耗时
     - 查看GC日志
- **常用命令**：
  - **系统命令**：
    - `top`、`htop`：查看进程和系统资源
    - `ps`：查看进程信息
    - `netstat`、`ss`：查看网络连接
    - `iostat`、`vmstat`：查看IO和内存统计
    - `sar`：系统活动报告
  - **Java命令**：
    - `jps`：查看Java进程
    - `jstack`：线程堆栈
    - `jmap`：内存映射
    - `jstat`：JVM统计
    - `jinfo`：JVM配置信息
  - **网络命令**：
    - `tcpdump`：网络抓包
    - `curl`、`wget`：HTTP请求测试
    - `ping`、`traceroute`：网络连通性
- **常用工具**：
  - **APM工具**：SkyWalking、Pinpoint、Zipkin
  - **监控工具**：Prometheus、Grafana
  - **日志工具**：ELK、Loki
  - **性能分析**：JProfiler、Arthas
  - **压测工具**：JMeter、wrk

---

## 6. 发生fullGC怎么排查?

**回答要点：**
- **Full GC的定义**：
  - 对整个堆内存进行垃圾回收
  - 包括新生代和老年代
  - 通常伴随较长的STW（Stop The World）时间
- **Full GC的触发条件**：
  - 老年代空间不足
  - 永久代/元空间不足
  - 显式调用`System.gc()`
  - CMS GC的Concurrent Mode Failure
  - G1 GC的并发标记失败
- **排查步骤**：
  1. **查看GC日志**：
     - 启用GC日志：`-XX:+PrintGCDetails -XX:+PrintGCDateStamps`
     - 分析Full GC频率和耗时
     - 查看GC原因（Allocation Failure、Metadata GC Threshold等）
  2. **分析堆内存**：
     - `jmap -heap <pid>`：查看堆使用情况
     - `jmap -histo <pid>`：查看对象分布
     - `jmap -dump`：生成堆快照分析
  3. **检查内存泄漏**：
     - 使用MAT、JProfiler分析堆快照
     - 查找占用内存大的对象
     - 检查是否有对象无法被GC回收
  4. **分析GC参数**：
     - 检查堆大小设置是否合理
     - 检查新生代和老年代比例
     - 检查GC算法选择
- **常见原因**：
  - **堆内存设置过小**：
    - 增加`-Xmx`和`-Xms`
    - 保证`Xms=Xmx`避免动态扩展
  - **内存泄漏**：
    - 集合类未及时清理
    - 监听器未注销
    - ThreadLocal未清理
  - **大对象频繁创建**：
    - 优化代码，减少大对象
    - 使用对象池
  - **元空间溢出**：
    - 增加`-XX:MetaspaceSize`
    - 检查动态代理和反射使用
- **解决方案**：
  - 调整JVM参数：堆大小、GC算法、GC参数
  - 优化代码：减少对象创建、及时释放资源
  - 使用合适的GC算法：G1、ZGC等
  - 监控和告警：及时发现Full GC问题

---

## 7. 使用分布式调度框架该考虑哪些问题?

**回答要点：**
- **高可用性**：
  - 调度中心集群部署，避免单点故障
  - 任务执行节点多实例部署
  - 支持故障自动转移
  - 数据持久化，防止任务丢失
- **任务分片**：
  - 支持任务分片执行
  - 分片策略：按数据量、按时间、按业务维度
  - 分片结果汇总
  - 处理分片失败重试
- **任务调度**：
  - 支持Cron表达式
  - 支持任务依赖关系
  - 支持任务优先级
  - 支持任务暂停、恢复、取消
- **负载均衡**：
  - 任务在多个执行节点间均衡分配
  - 考虑节点负载和资源使用
  - 支持节点动态上下线
- **任务监控**：
  - 任务执行状态监控
  - 任务执行时间统计
  - 失败任务告警
  - 任务执行日志查看
- **容错机制**：
  - 任务执行失败重试
  - 重试策略：固定次数、指数退避
  - 失败任务告警和通知
  - 支持任务补偿
- **数据一致性**：
  - 任务状态一致性
  - 避免重复执行（幂等性）
  - 分布式锁保证任务唯一执行
- **性能考虑**：
  - 调度中心性能：支持大量任务调度
  - 任务执行性能：合理设置并发数
  - 数据库性能：任务状态存储优化
- **安全性**：
  - 任务执行权限控制
  - 任务参数加密
  - 防止任务被恶意执行
- **开源框架对比**：
  - **XXL-JOB**：轻量级，易用
  - **Elastic-Job**：功能丰富，支持分片
  - **Quartz Cluster**：成熟稳定
  - **SchedulerX**：阿里云服务

---

## 8. 为什么复杂的架构一定要做分层设计?

**回答要点：**
- **职责分离**：
  - 每一层专注于自己的职责
  - 降低代码耦合度
  - 提高代码可维护性
  - 便于团队协作开发
- **常见的分层架构**：
  - **MVC分层**：Model、View、Controller
  - **三层架构**：表现层、业务层、数据层
  - **四层架构**：表现层、业务层、服务层、数据层
  - **DDD分层**：用户接口层、应用层、领域层、基础设施层
- **分层设计的优势**：
  - **可维护性**：
    - 修改某一层不影响其他层
    - 问题定位更容易
    - 代码结构清晰
  - **可扩展性**：
    - 可以独立扩展某一层
    - 支持水平扩展
    - 便于引入新技术
  - **可测试性**：
    - 每层可以独立测试
    - Mock依赖层进行单元测试
    - 提高测试覆盖率
  - **可复用性**：
    - 业务逻辑层可以复用
    - 数据访问层可以复用
    - 减少重复代码
- **分层设计的原则**：
  - **单一职责**：每层只做一件事
  - **依赖方向**：上层依赖下层，不能反向依赖
  - **接口隔离**：层间通过接口交互
  - **开闭原则**：对扩展开放，对修改关闭
- **分层设计的挑战**：
  - 可能增加系统复杂度
  - 层间调用可能影响性能
  - 需要合理设计层间接口
  - 避免过度设计

---

## 9. 为什么高并发下数据写入不推荐关系数据库?

**回答要点：**
- **关系数据库的局限性**：
  - **ACID特性带来的开销**：
    - 事务保证需要锁机制
    - 写操作需要持久化到磁盘
    - 日志记录（redo log、undo log）增加IO
  - **锁竞争**：
    - 行锁、表锁导致并发写入性能下降
    - 死锁检测和处理开销
    - 锁等待影响吞吐量
  - **磁盘IO瓶颈**：
    - 随机写性能差
    - 数据页刷盘影响性能
    - 索引维护增加写入开销
  - **扩展性限制**：
    - 垂直扩展有限
    - 水平扩展（分库分表）复杂
    - 主从复制延迟
- **高并发写入的替代方案**：
  - **消息队列**：
    - Kafka、RocketMQ等
    - 高吞吐量，支持批量写入
    - 异步处理，削峰填谷
  - **NoSQL数据库**：
    - MongoDB：文档数据库，写入性能好
    - Cassandra：分布式，高可用
    - HBase：列式存储，适合大数据
  - **时序数据库**：
    - InfluxDB、TimescaleDB
    - 针对时序数据优化
    - 高写入性能
  - **内存数据库**：
    - Redis：高性能，适合缓存
    - Memcached：简单高效
- **混合架构**：
  - 写入：消息队列 → 异步处理 → 批量写入数据库
  - 读取：关系数据库 + 缓存
  - 保证最终一致性
- **关系数据库仍适用的场景**：
  - 需要强一致性
  - 需要复杂查询和事务
  - 数据量不是特别大
  - 对写入性能要求不是极高

---

## 10. rpc中的简易注册中心怎么实现的?

**回答要点：**
- **注册中心的核心功能**：
  - 服务注册：服务提供者注册服务信息
  - 服务发现：服务消费者发现可用服务
  - 服务健康检查：检测服务可用性
  - 服务变更通知：服务上下线通知
- **简易实现方案**：
  - **基于内存实现**：
    ```java
    // 使用ConcurrentHashMap存储服务信息
    Map<String, List<ServiceInfo>> serviceRegistry
    
    // 服务注册
    void register(String serviceName, ServiceInfo info)
    
    // 服务发现
    List<ServiceInfo> discover(String serviceName)
    
    // 服务注销
    void unregister(String serviceName, ServiceInfo info)
    ```
  - **基于Redis实现**：
    - 使用Redis的Hash结构存储服务信息
    - Key：服务名，Field：服务实例ID，Value：服务信息JSON
    - 使用过期时间实现服务健康检查
    - 服务提供者定时续约（心跳）
  - **基于Zookeeper实现**：
    - 创建临时节点存储服务信息
    - 节点自动删除实现服务下线
    - Watch机制实现服务变更通知
- **关键设计点**：
  - **数据结构**：
    - 服务名 → 服务实例列表
    - 服务实例信息：IP、端口、权重、版本等
  - **服务注册**：
    - 服务启动时注册
    - 支持多实例注册
    - 注册信息包含元数据
  - **服务发现**：
    - 按服务名查询
    - 支持负载均衡（随机、轮询、加权）
    - 缓存服务列表，减少查询
  - **健康检查**：
    - 心跳机制：服务提供者定时上报
    - 主动探测：注册中心主动检查
    - 自动剔除：失效服务自动移除
  - **变更通知**：
    - 推送模式：服务变更主动通知
    - 拉取模式：客户端定时拉取
    - 混合模式：推送+拉取结合
- **性能优化**：
  - 本地缓存服务列表
  - 批量注册和发现
  - 异步处理注册请求
  - 数据压缩减少网络传输
- **高可用设计**：
  - 注册中心集群部署
  - 数据持久化
  - 故障自动转移
  - 最终一致性

---

## 11. 如何设计一个敏感词过滤系统? CATL

**回答要点：**
- **需求分析**：
  - 实时过滤：用户输入时实时检测
  - 高并发：支持大量并发请求
  - 准确性：不能误判和漏判
  - 可扩展：支持敏感词动态更新
- **核心算法**：
  - **Trie树（字典树）**：
    - 构建敏感词字典树
    - 快速匹配敏感词
    - 支持前缀匹配
  - **AC自动机**：
    - 基于Trie树的多模式匹配
    - 支持同时匹配多个敏感词
    - 时间复杂度O(n)，n为文本长度
  - **DFA（确定有限状态自动机）**：
    - 状态转换表
    - 高效匹配算法
- **系统架构**：
  - **敏感词库管理**：
    - 敏感词分类管理
    - 支持敏感词添加、删除、修改
    - 敏感词分级（严重、一般、轻微）
  - **过滤引擎**：
    - 文本预处理：去除空格、特殊字符
    - 敏感词匹配：使用AC自动机或DFA
    - 结果处理：替换、标记、拦截
  - **缓存层**：
    - 敏感词字典树缓存
    - 热点文本缓存
    - 减少重复计算
  - **存储层**：
    - 敏感词库存储（MySQL、Redis）
    - 过滤日志存储
    - 统计分析数据
- **宁德时代（CATL）场景特点**：
  - **工业数据安全**：
    - 技术参数、商业机密保护
    - 防止敏感信息泄露
  - **实时性要求**：
    - 生产数据实时过滤
    - 低延迟响应
  - **高并发**：
    - 大量设备数据上报
    - 需要高性能过滤
- **性能优化**：
  - **多级缓存**：
    - 本地缓存：JVM内存缓存字典树
    - 分布式缓存：Redis缓存热点数据
  - **异步处理**：
    - 非关键路径异步过滤
    - 使用消息队列削峰
  - **算法优化**：
    - 敏感词字典树压缩
    - 使用位图优化内存
    - 并行匹配提高速度
- **功能扩展**：
  - **模糊匹配**：
    - 支持拼音、谐音检测
    - 支持形近字检测
    - 支持特殊字符插入检测
  - **白名单机制**：
    - 特定场景允许使用
    - 白名单优先级高于黑名单
  - **统计分析**：
    - 敏感词命中统计
    - 用户行为分析
    - 风险等级评估

---

## 12. 创建索引需要考虑哪些问题?

**回答要点：**
- **索引选择**：
  - **哪些列需要索引**：
    - WHERE子句中的列
    - JOIN关联的列
    - ORDER BY、GROUP BY的列
    - 高选择性（区分度大）的列
  - **哪些列不需要索引**：
    - 低选择性列（如性别、状态）
    - 频繁更新的列
    - 很少用于查询的列
    - 数据量小的表
- **索引类型选择**：
  - **普通索引**：最基本的索引
  - **唯一索引**：保证列值唯一
  - **主键索引**：特殊的唯一索引
  - **联合索引**：多列组合索引
  - **全文索引**：用于文本搜索
  - **覆盖索引**：包含查询所需的所有列
- **联合索引设计**：
  - **最左前缀原则**：
    - 索引列顺序很重要
    - 查询必须使用最左列
    - 例：索引(a,b,c)，可用(a)、(a,b)、(a,b,c)
  - **列顺序选择**：
    - 选择性高的列在前
    - 等值查询列在前，范围查询列在后
    - 考虑查询频率
- **索引维护成本**：
  - **存储空间**：
    - 索引占用额外存储空间
    - 联合索引空间更大
  - **写入性能**：
    - 插入、更新、删除需要维护索引
    - 索引越多，写入越慢
  - **维护成本**：
    - 定期重建索引
    - 监控索引使用情况
- **索引使用注意事项**：
  - **避免索引失效**：
    - 不在索引列使用函数
    - 避免类型转换
    - 注意前导模糊查询
  - **索引数量控制**：
    - 单表索引不宜过多（建议<5个）
    - 避免冗余索引
    - 定期清理无用索引
- **索引监控**：
  - 使用`EXPLAIN`分析执行计划
  - 查看索引使用统计
  - 监控慢查询日志
  - 分析索引效果
- **特殊场景**：
  - **分区表索引**：
    - 本地索引 vs 全局索引
    - 考虑分区键
  - **大表索引**：
    - 在线创建索引
    - 分阶段创建
    - 考虑索引维护时间窗口

---

## 补充说明

- 以上答案仅供参考，实际面试中需要结合具体项目经验
- 建议准备具体的代码示例和项目案例
- 关注vivo的业务场景，结合业务回答问题
- 保持逻辑清晰，表达流畅

